package kotlinspecific

/**
 * Generics
 * allow you to defines types that have "type parameters"
 * when instance of these types are created, those parameters are replaced by "type arguments"
 *
 * Can have generic type parameters at method of class, interface, top level function, extension function
 * You can’t declare a generic non-extension property
 */

/**
 * Generic function
 * Not that the first <T> is used to declare the type parameter
 * */
fun <T> List<T>.firstThree(): List<T> {
    return if (size <= 3) this else this.subList(0, 3)
}

/**
 * Generic Class Example
 */
interface CustomList<T> {
    operator fun get(index: Int): T
}

class StringCustomList : CustomList<String> {
    /* This class provide the specific type argument, T is replaced by Strings*/
    override fun get(index: Int): String = "Its sth"
    // val <S> x: S = TODO() // not possible for non-extension properties to be generate
}

class ArrayCustomList<T> : CustomList<T> {
    /*the Type parameter are supposed to be another type parameter */
    override fun get(index: Int): T = this[index]
}

/**
 * Generic Type with constraints
 */

fun <T : Number> List<T>.sum(): T { // T must be subclass of Number
    // in Java its is <T extends Number>
    TODO("implement method")
}

fun <T : Comparable<T>> max(first: T, second: T): T {
    return if (first > second) first else second
}

/**
 *  Generic Type with multiple constraints
 */
fun <T> ensureTrailingPeriod(seq: T)
        where T : CharSequence, T : Appendable {
    if (!seq.endsWith('.')) {
        seq.append('.')
    }
}

/**
 * Ensure the Generic Type is non-nullable
 */

class Processor<T : Any> { // bound it with Any
    fun process(value: T) {
        value.hashCode()
    }
}










/**
 * Section 2
 * Generics at runtimes
 * generally type arguments are erased List<Int>, List<String> are just List
 * unless the function is inline
 *
 */

fun checkIfIsType(randomList : Any, intCollection: Collection<Int>) {


//    val firstTest = randomList is List<Int>
//    print("randomList is List<Int>$firstTest")

    //casting is non-safe
    //randomList as List<Int>

    val secondTest = randomList is List<*>
    print("randomList is List<*>$secondTest")

    val thirdTest = intCollection is List<Int>
    print("intCollection is List<int>$thirdTest")
    // as the input is already Int, the type is known
}

fun typeCasting(randomList : Any){
    //compiler will only give warning
    val aList = randomList as List<*> ?: throw IllegalArgumentException("wrong argument")
    print(aList.get(0))
    val intList = randomList as List<Int> ?: throw IllegalArgumentException("wrong argument")
    print(intList.get(0))

}

/** functions with reified type parameters */
// fun <T> isT(value: Any) = value is T
// this function will give error as the function
// try to check the type argument ar RUNTIME but it is erased at RUNTIME

//in order to use the above, mark inline and reified.
inline fun <reified T> isT(value: Any) = value is T

// non trivial example of the use of reified type argument
inline fun <reified T> Iterable<*>.simpleFilterIsInstance(): List<T>{
    val destination = mutableListOf<T>()
    for (element in this) {
        if (element is T) {
            destination.add(element)
        }
    }
    return destination
}

//note that reification only work with inline because the type is known when function are inlined
// as the bytecode is copied at every place the inline function is called, instead of function reference
//the generated bytecode references a specific class, not type parameter
//inline/reification function cant be called from Java as inline function are just normal function
// note that inline function are supposed to be small, as it will have impact on the result size of execuable

/**
 *  limitation for reified type parameter
 *  CAN
 *  1. type check , is/as
 *  2. Kotlin reflection api (::class) to be discussed
 *  3. ::class.java
 *  4. as type argument to call other function
 *
 *  CANT
 *  create new instances of class of type parameter
 *  call method on companion object of type parameter class
 *  use non-reified type para as type argument when calling a function with a reified type para
 *  mark type parameters of classes,properties, or non-inline functions as reified.
 *
 *  as reified type para can only be used in inline functions, using a reified type parameter means the function
 *  alone with all lambdas are inlined. if you dont want those lambdas to be inlines, you can use 'noinline'
 *  for those lambda
 */


/**
 * When is it safe to pass a lists of Strings to a function that expect a list of Any?
 * When its read-only, its safe , e.g. print all element out
 * WHen its add/replace the list, its not. e.g. add int to the list
 * */


/** List is a class, not a type, but List<Int>, List<String?> are valid type
 * one generic class can produces a potentially infinite types
 */

/** assign subtype to declared super type variable is ok, not the other way around*/





/** Testing zone myself, not from book */
interface BaseDto{
    fun printiam()
}

class Herd<out T:BaseDto>{
    //    fun printbyiam(){
//        (T as BaseDto)
//    }
    fun <T> printthey(animal:T){
        (animal as BaseDto).printiam()
    }
}

class Cat:BaseDto{
    override fun printiam(){
        print("i am cat")
    }
}

class Dog:BaseDto{
    override fun printiam(){
        print("i am dog")
    }
}
/** Testing zone myself, not from book */


/**If a function accepts a read-only list, you can pass a List with a more specific
element type. If the list is mutable, you can’t do that. */

fun main(){
    val a = listOf(1,2,3)
    val b = "String"

    a.firstThree()
    checkIfIsType(b,a)
    typeCasting(a);typeCasting(b);
    val items = listOf("one", 2, "three")
    println(items.simpleFilterIsInstance<String>())

}